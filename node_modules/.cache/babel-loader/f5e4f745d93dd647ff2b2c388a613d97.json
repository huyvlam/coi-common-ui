{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/*\n * COI Data Dictionary - Input Validation\n */\nimport DictionaryCore from 'LIB/coi-dictionary/DictionaryCore';\nimport { VALIDATION_TYPE_CONTAINS, VALIDATION_TYPE_DICT_NAME, VALIDATION_TYPE_EQUAL, VALIDATION_TYPE_UNEQUAL, VALIDATION_TYPE_ALL, VALIDATION_TYPE_LENGTH, VALIDATION_TYPE_ONE_OF, VALIDATION_TYPE_REGEX } from 'LIB/coi-dictionary/metadata/validation-type';\nimport { checkContains, checkDictionaryField, checkEqual, checkUnequal, checkLength, checkRegex, isPrimitive, validateInputList } from 'LIB/coi-dictionary/util/validation-helper';\n\nvar InputValidation =\n/*#__PURE__*/\nfunction (_DictionaryCore) {\n  _inherits(InputValidation, _DictionaryCore);\n\n  function InputValidation() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        revisedFields = _ref.revisedFields,\n        locale = _ref.locale;\n\n    _classCallCheck(this, InputValidation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InputValidation).call(this, {\n      revisedFields: revisedFields,\n      locale: locale\n    }));\n    _this.validateList = validateInputList;\n    return _this;\n  } // fetchDictionaryFields()\n  // reviseFields()\n  // findField()\n\n\n  _createClass(InputValidation, [{\n    key: \"validateInput\",\n    value: function validateInput(_ref2) {\n      var pristine = _ref2.pristine,\n          value = _ref2.value,\n          validation = _ref2.validation;\n      var required = validation.required,\n          type = validation.type,\n          specs = validation.specs;\n      /*\n       * @desc: if field is pristine or has no validation info -> skip validation\n       * @output: null\n       */\n\n      if (pristine || !validation || !type || !specs) {\n        return null;\n      }\n      /*\n       * @desc: if field is required but has no value, return status 'empty'\n       * @output: object with status, valid\n       */\n\n\n      if (required && !isPrimitive(value)) {\n        // Add description and condition check for type \"all\". This hack is needed to display description list\n        var description = validation.specs.description;\n        return type === VALIDATION_TYPE_ALL ? this.iterateAll({\n          pristine: pristine,\n          value: value,\n          validation: validation\n        }) : {\n          status: 'empty',\n          valid: false,\n          description: description\n        };\n      }\n      /*\n       * @desc: validate input value using validation specs and data dictionary\n       */\n\n\n      var dictField = this.findField(specs.dictField);\n\n      switch (type) {\n        case VALIDATION_TYPE_CONTAINS:\n          return checkContains(value, _objectSpread({}, dictField, {}, specs));\n\n        case VALIDATION_TYPE_DICT_NAME:\n          return checkDictionaryField(value, _objectSpread({}, dictField, {}, specs));\n\n        case VALIDATION_TYPE_EQUAL:\n          return checkEqual(value, _objectSpread({}, dictField, {}, specs));\n\n        case VALIDATION_TYPE_UNEQUAL:\n          return checkUnequal(value, _objectSpread({}, dictField, {}, specs));\n\n        case VALIDATION_TYPE_LENGTH:\n          return checkLength(value, _objectSpread({}, dictField, {}, specs));\n\n        case VALIDATION_TYPE_ALL:\n          return this.iterateAll({\n            pristine: pristine,\n            value: value,\n            validation: validation\n          });\n\n        case VALIDATION_TYPE_ONE_OF:\n          return this.iterate({\n            pristine: pristine,\n            value: value,\n            validation: validation\n          });\n\n        case VALIDATION_TYPE_REGEX:\n          return checkRegex(value.trim(), _objectSpread({}, dictField, {}, specs));\n\n        /*\n         * @desc: if validation type is not identified -> skip validation\n         * @output: null\n         */\n\n        default:\n          return null;\n      }\n    }\n    /*\n     * @desc: Iterate thru the list of validation specs, check and make sure all requirements are met\n     * @output: Return object or null\n     */\n\n  }, {\n    key: \"iterateAll\",\n    value: function iterateAll(_ref3) {\n      var _this2 = this;\n\n      var value = _ref3.value,\n          pristine = _ref3.pristine,\n          _ref3$validation = _ref3.validation,\n          validation = _ref3$validation === void 0 ? {} : _ref3$validation;\n\n      var _ref4 = validation.specs || {},\n          all = _ref4.all;\n\n      if (!all.length) return null;\n      var validCount = 0,\n          statusList = [];\n      all.forEach(function (eachSpec) {\n        var eachStatus = _this2.validateInput({\n          value: value,\n          pristine: pristine,\n          validation: eachSpec\n        });\n\n        if (!eachStatus) {\n          validCount--;\n        }\n\n        var valid = eachStatus.valid;\n\n        if (valid && validCount < all.length) {\n          validCount++;\n        }\n\n        if (!valid && validCount > 0) {\n          validCount--;\n        }\n\n        statusList = [].concat(_toConsumableArray(statusList), [eachStatus]);\n      });\n      var valid = validCount === all.length;\n      var status = valid ? 'completed' : 'error';\n      return {\n        status: status,\n        valid: valid,\n        descriptionList: statusList\n      };\n    }\n    /*\n     * @desc: Iterate thru the list of validation specs, if the first requirement is null, move onto next requirement\n     *        If any requirement returns an object with validation result, stop and return the validation output\n     * @output: Return object or null\n     */\n\n  }, {\n    key: \"iterate\",\n    value: function iterate(_ref5) {\n      var value = _ref5.value,\n          pristine = _ref5.pristine,\n          validation = _ref5.validation;\n      var specs = validation.specs;\n      var oneOf = specs.oneOf;\n      if (!oneOf.length) return null;\n\n      for (var i = 0; i < oneOf.length; i++) {\n        var validateField = this.validateInput({\n          value: value,\n          pristine: pristine,\n          validation: oneOf[i]\n        });\n        if (validateField) return validateField;\n      }\n    }\n  }]);\n\n  return InputValidation;\n}(DictionaryCore);\n\nexport default InputValidation;","map":null,"metadata":{},"sourceType":"module"}